<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>glitch-network (mobile-safe)</title>
<style>
  html,body { margin:0; height:100%; background:#000; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; }
  #ui {
    position:fixed; top:12px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.45); padding:10px 16px; border-radius:12px;
    font-family:system-ui, sans-serif; font-size:16px; color:#fff;
    border:1px solid rgba(255,255,255,.25); display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  }
  button {
    appearance:none; background:#111; border:1px solid #59f; border-radius:8px;
    color:#59f; padding:10px 16px; font-size:16px; cursor:pointer;
  }
  input[type="range"]{ width:120px; }
  #status { font-size:12px; color:#9af; opacity:.95 }
  /* Native controls are hidden unless we really need them */
  #player { position:fixed; left:12px; bottom:12px; width:calc(100% - 24px); display:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <button id="loadBtn">üìÅ Load</button>
  <button id="playBtn">‚ñ∂Ô∏è Play</button>
  <button id="pauseBtn">‚è∏ Pause</button>
  <label style="display:flex;align-items:center;gap:6px;">
    Vol <input id="vol" type="range" min="0" max="1" step="0.01" value="1">
  </label>
  <span id="status"></span>
</div>

<!-- Hidden audio element (decoded by Safari). We route it via WebAudio. -->
<audio id="player" playsinline preload="auto"></audio>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
const player = document.getElementById("player");
const vol = document.getElementById("vol");
const loadBtn = document.getElementById("loadBtn");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");

let W,H,DPR=Math.max(1,Math.min(window.devicePixelRatio||1,2));
function resize(){ W=canvas.width=innerWidth*DPR; H=canvas.height=innerHeight*DPR; }
addEventListener("resize",resize,{passive:true}); resize();

function setStatus(msg){ statusEl.textContent = msg || ""; }

// ---- Audio: <audio> + WebAudio routing ----
let actx, analyser, dataArray, srcNode, gainNode, urlRef=null, started=false;

function ensureAudio(){
  if (actx) return;
  const AC = window.AudioContext || window.webkitAudioContext;
  actx = new AC({ latencyHint: "interactive" });

  analyser = actx.createAnalyser();
  analyser.fftSize = 512;
  dataArray = new Uint8Array(analyser.frequencyBinCount);

  gainNode = actx.createGain();
  gainNode.gain.value = +vol.value;
  gainNode.connect(actx.destination);
  vol.oninput = () => { if (gainNode) gainNode.gain.value = +vol.value; };
}

async function resumeCtx(){ if (actx && actx.state !== "running") { try { await actx.resume(); } catch(_) {} } }

function bindGraphOnce(){
  if (srcNode) return;
  // One MediaElementSource per <audio> for lifetime
  srcNode = actx.createMediaElementSource(player);
  srcNode.connect(analyser);     // visuals
  srcNode.connect(gainNode);     // speakers
  // IMPORTANT: mute element's own output to avoid double audio; WebAudio handles playback
  player.muted = true;
}

function revokeOldURL(){ if (urlRef) { URL.revokeObjectURL(urlRef); urlRef = null; } }

async function loadFileViaPicker(){
  ensureAudio();
  await resumeCtx();

  const inp = document.createElement("input");
  inp.type = "file";
  // If you truly want "any file", leave accept empty; we‚Äôll error if unsupported.
  // inp.accept = "";
  // If you want to hint, uncomment:
  // inp.accept = ".mp3,.m4a,.aac,.wav,.alac,.aif,.aiff,.caf,.flac,.ogg";
  inp.onchange = async () => {
    if (!(inp.files && inp.files[0])) return;
    const file = inp.files[0];
    revokeOldURL();
    ensureAudio();
    bindGraphOnce();

    // Point <audio> at blob URL
    urlRef = URL.createObjectURL(file);
    player.src = urlRef;
    player.loop = true;
    setStatus("Loading‚Ä¶");

    try { await player.play(); started = true; setStatus(""); }
    catch(e){
      // If autoplay disallowed, show native controls so user can press Play
      player.controls = true;
      player.style.display = "block";
      setStatus("Tap Play on the control bar to start.");
    }
  };
  inp.click();
}

async function play(){
  ensureAudio();
  bindGraphOnce();
  await resumeCtx();
  try { await player.play(); started = true; setStatus(""); }
  catch(e){
    player.controls = true;
    player.style.display = "block";
    setStatus("Tap Play on the control bar to start.");
  }
}
function pause(){ try { player.pause(); } catch(_){} }

// Handle media errors (unsupported codec, bad file, etc.)
player.addEventListener("error", () => {
  const err = player.error;
  let msg = "Playback error.";
  if (err){
    // MediaError codes: 1 ABORTED, 2 NETWORK, 3 DECODE, 4 SRC_NOT_SUPPORTED
    const map = {1:"aborted",2:"network",3:"decode",4:"src not supported"};
    msg = `Playback error (${map[err.code]||err.code}).`;
  }
  setStatus(msg + " Try MP3, M4A/AAC, WAV, or ALAC on iPhone.");
  // Expose native controls so user can try again or scrub
  player.controls = true;
  player.style.display = "block";
});

// Ensure graph is live if user taps Play on native controls
player.addEventListener("play", async () => { await resumeCtx(); started = true; setStatus(""); });

// UI buttons
loadBtn.onclick = loadFileViaPicker;
playBtn.onclick = play;
pauseBtn.onclick = pause;

// ---- Visuals: glitchy architectural network ----
const N=160, nodes=[];
for(let i=0;i<N;i++){
  nodes.push({ x:Math.random()*W, y:Math.random()*H,
               vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2,
               r:2+Math.random()*3 });
}

function energy(){
  if(!started || !analyser) return 0;
  analyser.getByteFrequencyData(dataArray);
  let s=0; for (let v of dataArray) s+=v;
  return s/(dataArray.length*255);
}

function draw(){
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0,0,W,H);

  const e = energy();
  if (!started) setStatus("Tap Load, choose a file, then Play.");

  // More chaotic ‚Äúarchitecture‚Äù feel
  for (let n of nodes){
    if (Math.random() < 0.025 + e*0.08) {
      n.vx += (Math.random()-0.5)*12*e;
      n.vy += (Math.random()-0.5)*12*e;
      if (Math.random() < 0.004 + e*0.012) { n.x = Math.random()*W; n.y = Math.random()*H; }
    }
    n.x += n.vx; n.y += n.vy;
    if (n.x<0||n.x>W) n.vx*=-1;
    if (n.y<0||n.y>H) n.vy*=-1;

    ctx.beginPath();
    ctx.arc(n.x,n.y,n.r,0,Math.PI*2);
    ctx.fillStyle = `hsl(${170+e*210},80%,${45+e*40}%)`;
    ctx.fill();
  }

  // Edges / scaffolding with mid-segment jitter
  const reach = 120 + e*240;
  ctx.lineWidth = 0.8 + e*2.4;
  for (let i=0;i<N;i++){
    for (let j=i+1;j<N;j++){
      const dx=nodes[i].x-nodes[j].x, dy=nodes[i].y-nodes[j].y, d=Math.hypot(dx,dy);
      if (d < reach){
        const a = 1 - d/(reach+1);
        ctx.strokeStyle = `rgba(180,210,255,${0.07 + a*0.55})`;
        ctx.beginPath();
        ctx.moveTo(nodes[i].x, nodes[i].y);
        const mx = (nodes[i].x + nodes[j].x)/2 + (Math.random()-0.5)*8*e;
        const my = (nodes[i].y + nodes[j].y)/2 + (Math.random()-0.5)*8*e;
        ctx.lineTo(mx, my);
        ctx.lineTo(nodes[j].x, nodes[j].y);
        ctx.stroke();
      }
    }
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>