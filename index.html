<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>glitch-mesh ‚Äî fast + MIDI Learn + HiDPI/Supersample</title>
<style>
  :root { color-scheme: dark; }
  html,body { margin:0; height:100%; background:#000; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; }

  /* Bottom drawer */
  #ui {
    position:fixed; left:50%; bottom:58px; transform:translate(-50%, 12px);
    width:min(1200px, 100vw - 20px); max-height:65vh; overflow-y:auto;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.25);
    border-radius:14px; padding:10px 12px; font:14px system-ui, sans-serif; color:#fff;
    box-shadow:0 8px 30px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.06) inset;
    z-index:10; transition: transform .25s ease, opacity .25s ease;
    opacity:.0; pointer-events:none; -webkit-overflow-scrolling: touch;
  }
  #ui.open { transform:translate(-50%,0); opacity:1; pointer-events:auto; }

  .g { display:flex; flex-direction:column; gap:2px; }
  .g label { font-size:12px; opacity:.85 }
  .g input[type="range"] { width:140px; }
  .g input[type="checkbox"] { width:18px; height:18px; }

  select { background:#111; color:#fff; border:1px solid rgba(255,255,255,.25); border-radius:8px; padding:6px 8px; }
  button {
    appearance:none; background:#111; color:#7fb0ff; border:1px solid #7fb0ff;
    padding:9px 14px; border-radius:9px; font:14px system-ui,sans-serif; cursor:pointer;
  }
  button.active { color:#f0baff; border-color:#f0baff; box-shadow:0 0 0 2px rgba(240,186,255,.2) inset; }

  #fps, #res { font-size:12px; color:#9ad; opacity:.85; margin-left:4px }
  #midiStatus { font-size:12px; color:#9f9; opacity:.9; min-width:200px }
  .midi-badge {
    display:inline-block; margin-top:2px; width:max-content; font-size:11px; color:#bfe1ff;
    background:rgba(127,176,255,.12); border:1px solid rgba(127,176,255,.3);
    border-radius:999px; padding:2px 6px;
  }
  .learn-target { outline:2px solid #7fb0ff; border-radius:12px; box-shadow:0 0 0 4px rgba(127,176,255,.22); }

  /* Bottom toggle pill */
  #uiToggleWrap {
    position:fixed; left:50%; bottom:10px; transform:translateX(-50%);
    background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.25);
    border-radius:999px; padding:8px 12px; color:#fff; font:13px system-ui,sans-serif;
    display:flex; align-items:center; gap:8px; z-index:11;
    box-shadow:0 4px 16px rgba(0,0,0,.4); user-select:none;
  }
  #uiToggle { width:18px; height:18px; accent-color:#7fb0ff; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- Bottom drawer controls -->
<div id="ui">
  <!-- Structure -->
  <div class="g"><label>Nodes</label><input id="nodes" type="range" min="40" max="500" step="10" value="160"><span class="midi-badge" hidden></span></div>
  <!-- Link Radius max reduced to 80% (500 ‚Üí 400) -->
  <div class="g"><label>Link Radius</label><input id="radius" type="range" min="40" max="400" step="5" value="180"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Edge Thicc</label><input id="thick" type="range" min="0.4" max="4" step="0.1" value="1.2"><span class="midi-badge" hidden></span></div>
  <!-- NEW: Edge Budget (avg neighbors per node) -->
  <div class="g"><label>Edge Budget</label><input id="edgeBudget" type="range" min="4" max="48" step="1" value="16"></div>

  <!-- Motion/feel -->
  <div class="g"><label>Glitch (jitter)</label><input id="glitch" type="range" min="0" max="1.5" step="0.01" value="0.65"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Teleport</label><input id="tele" type="range" min="0" max="0.05" step="0.001" value="0.006"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Warp (time)</label><input id="warp" type="range" min="0.1" max="3" step="0.01" value="1.0"><span class="midi-badge" hidden></span></div>

  <!-- Trails/feedback -->
  <div class="g"><label>Trail (persistence)</label><input id="trail" type="range" min="0" max="0.95" step="0.01" value="0.6"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Trail Curve</label><input id="trailCurve" type="range" min="0" max="1" step="0.01" value="0.7"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Feedback (mix)</label><input id="feedback" type="range" min="0" max="1" step="0.01" value="0.18"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Feedback Curve</label><input id="fbCurve" type="range" min="0" max="1" step="0.01" value="0.6"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Feedback Warp</label><input id="fbWarp" type="range" min="0" max="1" step="0.01" value="0.35"><span class="midi-badge" hidden></span></div>

  <!-- Color -->
  <div class="g"><label>Fibo Hue Speed</label><input id="fiboSpeed" type="range" min="0" max="2" step="0.001" value="0.20"><span class="midi-badge" hidden></span></div>

  <!-- Psychedelia field -->
  <div class="g"><label>PSY On</label><input id="psyOn" type="checkbox" checked></div>
  <div class="g"><label>Psy Influence</label><input id="psyInf" type="range" min="0" max="1.5" step="0.01" value="0.6"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Symmetry</label><input id="psySym" type="range" min="2" max="16" step="1" value="6"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Field Freq</label><input id="psyFreq" type="range" min="0.5" max="8" step="0.01" value="3.0"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Layers</label><input id="psyLayers" type="range" min="1" max="8" step="1" value="4"><span class="midi-badge" hidden></span></div>
  <div class="g"><label>Field Flow</label><input id="psyFlow" type="range" min="0" max="2" step="0.01" value="0.5"><span class="midi-badge" hidden></span></div>

  <!-- Display / Resolution -->
  <div class="g"><label>Render Scale</label><input id="renderScale" type="range" min="1" max="2" step="0.05" value="1.00"></div>
  <div class="g"><label>HiDPI</label><input id="hidpi" type="checkbox"></div>
  <div class="g"><label>HiDPI Max 3√ó</label><input id="hidpi3" type="checkbox"></div>

  <!-- MIDI -->
  <div class="g"><label>MIDI</label><button id="midiEnable" type="button">üéπ Enable MIDI</button></div>
  <div class="g"><label>Learn</label><button id="midiLearn" type="button">üéØ Learn: Off</button></div>
  <div class="g"><label>Selected</label><button id="midiClearOne" type="button">‚ùå Clear Selected</button></div>
  <div class="g"><label>All</label><button id="midiClearAll" type="button">üóë Clear All</button></div>
  <span id="midiStatus">MIDI: idle</span>

  <!-- Actions / readouts -->
  <button id="random"  type="button">üé≤ Randomize</button>
  <button id="pause"   type="button">‚è∏ Pause</button>
  <span id="fps"></span>
  <span id="res"></span>
</div>

<!-- Bottom toggle pill -->
<div id="uiToggleWrap">
  <input id="uiToggle" type="checkbox" checked>
  <label for="uiToggle">Show controls</label>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);

  // Canvas + feedback buffer
  const cv = $('#c');
  const ctx = cv.getContext('2d');
  const fb = document.createElement('canvas');
  const fbc = fb.getContext('2d');

  let W=0, H=0;

  // --- Display / scale state ---
  let USE_HIDPI = false;
  let HIDPI_MAX3 = false;
  let RENDER_SCALE = 1.00;

  function effectiveScale(){
    const dpr = USE_HIDPI ? Math.min(window.devicePixelRatio || 1, HIDPI_MAX3 ? 3 : 2) : 1;
    return dpr * RENDER_SCALE;
  }

  function resize(){
    const scale = effectiveScale();
    W = cv.width  = Math.floor(innerWidth  * scale);
    H = cv.height = Math.floor(innerHeight * scale);
    fb.width = W; fb.height = H;
    updateResReadout();
  }
  addEventListener('resize', resize, {passive:true});

  // Drawer open/close
  const panel = $('#ui');
  const toggle = $('#uiToggle');
  function syncDrawer(){ panel.classList.toggle('open', toggle.checked); }
  toggle.addEventListener('change', syncDrawer);
  syncDrawer();

  // Sliders / toggles
  const UI = {
    nodes: $('#nodes'), radius: $('#radius'),
    edgeBudget: $('#edgeBudget'),
    trail: $('#trail'), trailCurve: $('#trailCurve'),
    feedback: $('#feedback'), fbCurve: $('#fbCurve'), fbWarp: $('#fbWarp'),
    glitch: $('#glitch'), tele:  $('#tele'), thick: $('#thick'),
    warp:  $('#warp'), fiboSpeed: $('#fiboSpeed'),
    psyOn: $('#psyOn'), psyInf: $('#psyInf'), psySym: $('#psySym'),
    psyFreq: $('#psyFreq'), psyLayers: $('#psyLayers'), psyFlow: $('#psyFlow'),
    renderScale: $('#renderScale'), hidpi: $('#hidpi'), hidpi3: $('#hidpi3'), res: $('#res')
  };

  // State
  let nodes = [];
  let playing = true;
  let last = performance.now();
  let timeScale = +UI.warp.value;

  // Fibonacci color state
  const GOLDEN_ANGLE = 137.50776405003785;
  let hueBase = Math.random()*360;
  let huePhase = 0;
  let edgeBase = Math.random()*360;
  let edgePhase = 0;

  // FPS
  const fpsEl = $('#fps'); let fpsAcc=0, fpsFrames=0, fpsT=0;

  // Utils
  const rnd  = (a=1)=> Math.random()*a;
  const rndN = (n=1)=> (Math.random()*2-1)*n;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const map = (v, inMin, inMax, outMin, outMax) => outMin + (outMax-outMin) * ((v-inMin)/(inMax-inMin));
  function decimalsOfStep(el){ const s=(el.step||'1').toString(); const p=s.indexOf('.'); return p<0?0:(s.length-p-1); }
  function setSliderValue(el, value){
    const min=+el.min, max=+el.max, step=parseFloat(el.step||'0');
    let v = clamp(value, min, max);
    if (step>0) v = Math.round(v/step)*step;
    const dec = decimalsOfStep(el);
    el.value = dec? v.toFixed(dec) : String(v);
    el.dispatchEvent(new Event('input', {bubbles:true}));
  }

  function updateResReadout(){
    const dpr = USE_HIDPI ? Math.min(window.devicePixelRatio || 1, HIDPI_MAX3 ? 3 : 2) : 1;
    const eff = (dpr * RENDER_SCALE).toFixed(2);
    UI.res.textContent = `Res ${eff}√ó  ‚Ä¢  ${W}√ó${H}px`;
  }
  function applyDisplaySettings(){
    RENDER_SCALE = parseFloat(UI.renderScale.value) || 1;
    USE_HIDPI = !!UI.hidpi.checked;
    HIDPI_MAX3 = !!UI.hidpi3.checked;
    resize();
  }

  // Sacred-geometry-ish field
  function fieldValue(x, y, t, sym, freq, layers){
    const sx = (x - W/2) / Math.max(W,H);
    const sy = (y - H/2) / Math.max(W,H);
    let vx = sx, vy = sy, v = 0.0, s = 1.0, rot = 0.0;
    const k = Math.max(2, sym|0), twopi = Math.PI*2;
    for (let i=0;i<layers;i++){
      const ang = Math.atan2(vy,vx), rad = Math.hypot(vx,vy);
      let wedge = ((ang % (twopi/k)) + twopi/k) % (twopi/k);
      let a = Math.abs(wedge - (twopi/k)/2);
      rot += 0.15;
      const c = Math.cos(rot), srot = Math.sin(rot);
      const rx = vx*c - vy*srot, ry = vx*srot + vy*c;
      v += Math.sin((rad*freq*s) - t*0.9 + a*2.4 + i*1.3) * (0.6/(i+1));
      v += Math.sin((rx*freq*1.7*s) + (ry*freq*1.3*s) + t*0.4 + i*0.7) * (0.4/(i+1));
      vx *= 1.9; vy *= 1.9; s *= 1.35;
    }
    return v;
  }
  function fieldForce(x, y, t, sym, freq, layers){
    const eps = 0.002 * Math.max(W,H);
    const f0 = fieldValue(x, y, t, sym, freq, layers);
    const fx = fieldValue(x+eps, y, t, sym, freq, layers);
    const fy = fieldValue(x, y+eps, t, sym, freq, layers);
    let gx = (fx - f0)/eps, gy = (fy - f0)/eps;
    const g = Math.hypot(gx,gy) + 1e-6;
    gx /= g; gy /= g;
    const swirl = 0.6; const sxF = -gy*swirl, syF = gx*swirl;
    return { fx: gx + sxF, fy: gy + syF, fval: f0 };
  }

  function makeNodes(N){
    nodes = Array.from({length:N}, (_,i) => ({
      x: rnd(W), y: rnd(H),
      vx: rndN(1.5), vy: rndN(1.5),
      r: 1.5 + Math.random()*3.5,
      idx: i
    }));
  }

  function applyFromSliders(){
    const desired = +UI.nodes.value|0;
    if (desired !== nodes.length) makeNodes(desired);
    timeScale = +UI.warp.value;
  }

  // Randomize with constraints; EXCLUDE display + edge budget
  function randomizeAll(){
    for (const inp of panel.querySelectorAll('input[type="range"]')) {
      const id = inp.id;
      if (id === 'renderScale' || id === 'edgeBudget') continue;

      const min = parseFloat(inp.min), max = parseFloat(inp.max), step = parseFloat(inp.step||'1');
      const span = max - min;

      if (id === 'trail') { // 50‚Äì95%
        const val = min + 0.50*span + Math.random()*(0.45*span);
        inp.value = (+val).toFixed(2);
        continue;
      }
      if (id === 'radius') { // 0‚Äì50%
        const val = min + Math.random()*(0.50*span);
        const v = Math.round(val/step)*step;
        inp.value = String(v);
        continue;
      }
      const raw = min + Math.random()*span;
      const decimals = (step.toString().split('.')[1]||'').length;
      inp.value = raw.toFixed(decimals);
    }
    applyFromSliders();

    // reseed palettes & motion
    hueBase = Math.random()*360;
    edgeBase = Math.random()*360;
    huePhase = 0; edgePhase = 0;
    for (const n of nodes){
      const speed = 1.5 + Math.random()*3.0;
      const ang = Math.random()*Math.PI*2;
      n.vx = Math.cos(ang)*speed; n.vy = Math.sin(ang)*speed;
    }
  }

  // Bind UI
  $('#random').addEventListener('click', randomizeAll);
  const pauseBtn = $('#pause');
  $('#pause').addEventListener('click', () => {
    playing=!playing; pauseBtn.textContent = playing ? '‚è∏ Pause' : '‚ñ∂Ô∏è Play';
  });
  UI.nodes.addEventListener('input', applyFromSliders);
  UI.warp.addEventListener('input', applyFromSliders);

  // Display events
  UI.renderScale.addEventListener('input', applyDisplaySettings);
  UI.hidpi.addEventListener('change', applyDisplaySettings);
  UI.hidpi3.addEventListener('change', applyDisplaySettings);

  // Initial sizing & nodes
  resize();
  makeNodes(+UI.nodes.value);

  // ---------- Performance: persistent spatial grid (typed arrays) ----------
  let gridCell = 64, gridCols = 0, gridRows = 0, heads = null, next = null;
  function ensureGrid(cell){
    const cols = Math.floor(W / cell) + 1;
    const rows = Math.floor(H / cell) + 1;
    if (!heads || cols!==gridCols || rows!==gridRows){
      gridCols = cols; gridRows = rows; gridCell = cell;
      heads = new Int32Array(cols*rows);
    }
    if (!next || next.length !== nodes.length){
      next = new Int32Array(nodes.length);
    }
    heads.fill(-1);
  }

  function binIndex(x,y){
    const cx = x < 0 ? 0 : (x >= W ? (W-1) : x) / gridCell | 0;
    const cy = y < 0 ? 0 : (y >= H ? (H-1) : y) / gridCell | 0;
    return cy*gridCols + cx;
  }

  // stable pair hash -> 0..1
  function pairHash(i,j){
    const a = (i+1)*73856093 ^ (j+1)*19349663;
    return (a >>> 0) / 4294967295;
  }

  // ---------- Optimized edge drawing (sampling + no sqrt in hot loop) ----------
  function drawEdgesFast(linkR, thick, psyON, psyInf, psySym, psyFreq, psyLayers, tField, now, edgePhaseQ){
    const reach0 = linkR * 0.6, reach1 = linkR;
    const reach02 = reach0*reach0, reach12 = reach1*reach1;

    // Build grid
    const cell = Math.max(12, linkR|0);
    ensureGrid(cell);
    for (let i=0;i<nodes.length;i++){
      const n = nodes[i];
      const idx = binIndex(n.x, n.y);
      next[i] = heads[idx];
      heads[idx] = i;
    }

    // Sampling probability to meet Edge Budget
    const N = nodes.length;
    const density = N / (W*H + 1e-6);
    const k_est = Math.PI * reach12 * density;        // expected neighbors per node (uniform)
    const targetK = +UI.edgeBudget.value;
    const baseP = clamp(targetK / (k_est + 1e-6), 0.0, 1.0);

    ctx.lineCap = 'round';

    for (let i=0;i<N;i++){
      const a = nodes[i];
      const acx = (a.x / cell) | 0, acy = (a.y / cell) | 0;

      for (let ny=acy-1; ny<=acy+1; ny++){
        if (ny<0 || ny>=gridRows) continue;
        for (let nx=acx-1; nx<=acx+1; nx++){
          if (nx<0 || nx>=gridCols) continue;
          for (let j = heads[ny*gridCols + nx]; j !== -1; j = next[j]){
            if (j <= i) continue; // de-dup

            const b = nodes[j];
            const dx = a.x - b.x, dy = a.y - b.y;
            const d2 = dx*dx + dy*dy;
            if (d2 >= reach12) continue;

            // Distance-based fade without sqrt
            const fade1 = 1 - (d2 / reach12); if (fade1 <= 0) continue;
            // Bias sampling toward closer edges so structure holds
            const p = baseP * (0.35 + 0.65 * fade1);
            if (Math.random() > p) continue;

            // Color from pair hash + stepped phase
            const ehue = (edgeBase + edgePhaseQ + pairHash(i,j)*360) % 360;

            // Midpoint jitter + optional field warp on thick pass
            let mx = (a.x+b.x)*0.5, my = (a.y+b.y)*0.5;
            let jx1 = rndN(6 + 22*fade1), jy1 = rndN(6 + 22*fade1);

            // THIN PASS (shorter reach, lower alpha)
            if (d2 < reach02){
              const fade0 = 1 - (d2 / reach02);
              const a0 = clamp(0.06 + 0.25*fade0, 0, 0.55);
              ctx.lineWidth = thick * 0.5;
              ctx.strokeStyle = `hsla(${ehue},95%,55%,${a0})`;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(mx + jx1, my + jy1);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }

            // THICK PASS (full reach, field warp)
            let jx = jx1, jy = jy1;
            if (psyON && psyInf>0){
              const Fm = fieldValue(mx,my,tField,psySym,psyFreq,psyLayers);
              const w = Math.sin(Fm*1.5+now*0.001)*8;
              jx += w; jy -= w;
            }
            const a1 = clamp(0.12 + 0.35*fade1, 0, 0.55);
            ctx.lineWidth = thick;
            ctx.strokeStyle = `hsla(${ehue},95%,55%,${a1})`;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(mx + jx, my + jy);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }
      }
    }
  }

  function draw(now){
    const dtRaw = Math.max(0, (now - last) / 1000); last = now;
    const dt = dtRaw * timeScale;

    if (playing){
      // Trails with curve
      const trailRaw = +UI.trail.value;
      const tCurve = +UI.trailCurve.value;
      const tExp = 1.2 + tCurve*3.0;
      const trailA = Math.pow(trailRaw, tExp);
      if (trailA <= 0.0001) ctx.clearRect(0,0,W,H);
      else { ctx.fillStyle = `rgba(0,0,0,${trailA})`; ctx.fillRect(0,0,W,H); }

      // Feedback echo (screen blend)
      const fbMix = +UI.feedback.value;
      const fbC   = +UI.fbCurve.value;
      const fbWarp = +UI.fbWarp.value;
      const k = 1.5 + fbC*3.5;
      let fbAlpha = 1 - Math.exp(-k * fbMix);
      const atten = 0.25 + 0.75 * (trailA);
      fbAlpha = clamp(fbAlpha * atten * 0.9, 0, 0.95);
      if (fbAlpha > 0.001){
        ctx.save();
        ctx.globalAlpha = fbAlpha;
        ctx.globalCompositeOperation = 'screen';
        ctx.translate(W/2, H/2);
        const s = 1 + fbWarp * 0.006;
        const r = fbWarp * 0.002;
        ctx.scale(s, s); ctx.rotate(r);
        ctx.translate(-W/2, -H/2);
        ctx.drawImage(fb, 0, 0, W, H);
        ctx.restore();
        ctx.globalCompositeOperation = 'source-over';
      }

      // Update Fibonacci phases
      const fiboSpeed = +UI.fiboSpeed.value;
      huePhase += fiboSpeed * dt * 360;
      if (huePhase > 36000) huePhase -= 36000;
      edgePhase += fiboSpeed * dt * 360;
      const EDGE_STEP_DEG = 24;
      const edgePhaseQ = Math.floor(edgePhase / EDGE_STEP_DEG) * EDGE_STEP_DEG;

      // Sacred field params
      const psyON = UI.psyOn.checked;
      const psyInf = +UI.psyInf.value;
      const psySym = +UI.psySym.value;
      const psyFreq = +UI.psyFreq.value;
      const psyLayers = +UI.psyLayers.value|0;
      const psyFlow = +UI.psyFlow.value;
      const tField = now*0.001 * psyFlow;

      // Sim params
      const jitter = +UI.glitch.value;
      const teleP  = +UI.tele.value;
      const linkR  = +UI.radius.value;
      const thick  = +UI.thick.value;

      // Nodes
      for (const n of nodes){
        if (Math.random() < (0.8*jitter) * dt) {
          n.vx += rndN(80*jitter) * dt;
          n.vy += rndN(80*jitter) * dt;
        }
        if (Math.random() < teleP * dt) { n.x = rnd(W); n.y = rnd(H); }

        if (psyON && psyInf>0){
          const F = fieldForce(n.x, n.y, tField, psySym, psyFreq, psyLayers);
          n.vx += F.fx * psyInf * dt * 60;
          n.vy += F.fy * psyInf * dt * 60;
          n.r = 2.0 + 1.2 * Math.abs(Math.sin(F.fval*0.8));
        }

        n.x += n.vx * dt * 60;
        n.y += n.vy * dt * 60;

        if (n.x < 0) { n.x = 0; n.vx = Math.abs(n.vx); }
        if (n.x > W) { n.x = W; n.vx = -Math.abs(n.vx); }
        if (n.y < 0) { n.y = 0; n.vy = Math.abs(n.vy); }
        if (n.y > H) { n.y = H; n.vy = -Math.abs(n.vy); }

        const hue = (hueBase + n.idx * GOLDEN_ANGLE + huePhase) % 360;
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fillStyle = `hsl(${hue},85%,${45 + Math.min(40, Math.hypot(n.vx,n.vy))}%)`;
        ctx.fill();
      }

      // Fast edges
      drawEdgesFast(linkR, thick, psyON, psyInf, psySym, psyFreq, psyLayers, tField, now, edgePhaseQ);

      // Snapshot for feedback
      fbc.clearRect(0,0,W,H);
      fbc.drawImage(cv, 0, 0, W, H);
    }

    // FPS
    fpsAcc += 1/Math.max(dtRaw, 1e-6); fpsFrames++; fpsT += dtRaw;
    if (fpsT > 0.5) { fpsEl.textContent = `${(fpsAcc/fpsFrames).toFixed(0)} fps`; fpsAcc=0; fpsFrames=0; fpsT=0; }

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);

  // Nice starting motion
  setTimeout(() => {
    hueBase = Math.random()*360;
    edgeBase = Math.random()*360;
    for (const n of nodes){
      const speed = 1.5 + Math.random()*3.0;
      const ang = Math.random()*Math.PI*2;
      n.vx = Math.cos(ang)*speed;
      n.vy = Math.sin(ang)*speed;
    }
  }, 250);

  // ===============================
  //        WEB MIDI + LEARN
  // ===============================
  const midiEnableBtn = $('#midiEnable');
  const midiLearnBtn  = $('#midiLearn');
  const midiClearOne  = $('#midiClearOne');
  const midiClearAll  = $('#midiClearAll');
  const midiStatusEl  = $('#midiStatus');

  let midiAccess = null;
  let learnMode  = false;
  let learnTarget = null;
  let bindings = [];
  const BINDINGS_KEY = 'glitchMeshMidiBindings_v1';

  function saveBindings(){ try{ localStorage.setItem(BINDINGS_KEY, JSON.stringify(bindings)); }catch(e){} }
  function loadBindings(){
    try {
      const raw = localStorage.getItem(BINDINGS_KEY);
      if (!raw) return;
      const arr = JSON.parse(raw);
      if (Array.isArray(arr)) {
        bindings = arr;
        for (const b of bindings){
          const el = document.getElementById(b.targetId);
          if (el) showBadge(el, bindingLabel(b));
        }
      }
    } catch(e){}
  }

  function setMidiStatus(msg, ok=true){
    midiStatusEl.textContent = 'MIDI: ' + msg;
    midiStatusEl.style.color = ok ? '#9f9' : '#f99';
  }

  function enableMIDI(){
    if (!('requestMIDIAccess' in navigator)){
      setMidiStatus('Web MIDI not supported. Use Chrome/Edge.', false);
      return;
    }
    navigator.requestMIDIAccess({ sysex:false }).then(access => {
      midiAccess = access;
      attachAllInputs();
      midiAccess.onstatechange = attachAllInputs;
      setMidiStatus('ready ‚Äî click Learn to bind controls');
      loadBindings();
    }, err => {
      console.error(err);
      setMidiStatus('access denied', false);
    });
  }

  function attachAllInputs(){
    if (!midiAccess) return;
    for (const input of midiAccess.inputs.values()){ try { input.onmidimessage = null; } catch(e){} }
    for (const input of midiAccess.inputs.values()){
      input.onmidimessage = (e) => handleMIDIMessage(e, input);
    }
  }

  midiEnableBtn.addEventListener('click', enableMIDI);

  midiLearnBtn.addEventListener('click', () => {
    learnMode = !learnMode;
    midiLearnBtn.classList.toggle('active', learnMode);
    midiLearnBtn.textContent = learnMode ? 'üéØ Learn: On' : 'üéØ Learn: Off';
    if (learnMode) setMidiStatus('LEARN: click a slider, then move a MIDI control‚Ä¶');
    else { clearLearnTarget(); setMidiStatus('learn off'); }
  });

  for (const inp of panel.querySelectorAll('input[type="range"]')){
    inp.addEventListener('click', () => {
      setLearnTarget(inp);
      if (learnMode) setMidiStatus(`LEARN: move a MIDI control for ‚Äú${inp.id}‚Äù`);
      else setMidiStatus(`Selected ‚Äú${inp.id}‚Äù`);
    });
  }

  midiClearOne.addEventListener('click', () => {
    if (!learnTarget) { setMidiStatus('no slider selected', false); return; }
    removeBindingForTarget(learnTarget.id);
    hideBadge(learnTarget);
    setMidiStatus(`cleared mapping for ‚Äú${learnTarget.id}‚Äù`);
    saveBindings();
  });

  midiClearAll.addEventListener('click', () => {
    bindings.length = 0;
    for (const inp of panel.querySelectorAll('input[type="range"]')) hideBadge(inp);
    setMidiStatus('cleared all mappings');
    saveBindings();
  });

  function setLearnTarget(el){ if (learnTarget) learnTarget.classList.remove('learn-target'); learnTarget = el; el.classList.add('learn-target'); }
  function clearLearnTarget(){ if (learnTarget) learnTarget.classList.remove('learn-target'); learnTarget = null; }

  function showBadge(el, text){ const b = el.parentElement.querySelector('.midi-badge'); if (b){ b.textContent = 'üîó ' + text; b.hidden = false; } }
  function hideBadge(el){ const b = el.parentElement.querySelector('.midi-badge'); if (b){ b.hidden = true; b.textContent=''; } }

  function removeBindingForTarget(targetId){ const before = bindings.length; bindings = bindings.filter(b => b.targetId !== targetId); return before !== bindings.length; }
  function bindingLabel(b){ switch(b.type){ case 'cc':return `CC${b.controller} ch${b.channel}`; case 'pb':return `PitchBend ch${b.channel}`; case 'at':return `Aftertouch ch${b.channel}`; case 'note':return `Note${b.note} ch${b.channel}`; default:return `MIDI ch${b.channel}`; } }

  function createBindingFromMessage(targetEl, msg){
    const deviceId = msg.deviceId, deviceName = msg.deviceName, channel = msg.channel;
    let binding = null;
    if (msg.type === 'cc') binding = { targetId: targetEl.id, type:'cc', channel, deviceId, controller: msg.cc, deviceName };
    else if (msg.type === 'pb') binding = { targetId: targetEl.id, type:'pb', channel, deviceId, deviceName };
    else if (msg.type === 'at') binding = { targetId: targetEl.id, type:'at', channel, deviceId, deviceName };
    else if (msg.type === 'note') binding = { targetId: targetEl.id, type:'note', channel, deviceId, note: msg.note, deviceName };
    if (!binding) return false;
    removeBindingForTarget(targetEl.id);
    bindings.push(binding);
    showBadge(targetEl, bindingLabel(binding));
    saveBindings();
    return true;
  }

  function matchesBinding(b, msg){
    if (!b || !msg) return false;
    if (b.deviceId !== msg.deviceId) return false;
    if (b.channel  !== msg.channel)  return false;
    if (b.type     !== msg.type)     return false;
    if (b.type === 'cc'   && b.controller !== msg.cc)   return false;
    if (b.type === 'note' && b.note       !== msg.note) return false;
    return true;
  }

  function applyMessageToBinding(b, msg){
    const el = document.getElementById(b.targetId); if (!el) return;
    let norm = 0;
    switch(msg.type){
      case 0x0: break;
      case 'cc':  norm = msg.value / 127; break;
      case 'at':  norm = msg.value / 127; break;
      case 'note': norm = msg.vel / 127; break;
      case 'pb':  norm = msg.value14 / 16383; break;
      default: return;
    }
    const min=+el.min, max=+el.max;
    const val = min + norm * (max - min);
    setSliderValue(el, val);
  }

  function handleMIDIMessage(e, input){
    const d = e.data; if (!d || d.length===0) return;
    const status = d[0]; if (status >= 0xF8) return; // ignore realtime here
    const typeByte = status & 0xF0;
    const channel = (status & 0x0F) + 1;
    const deviceId = input && input.id || 'unknown';
    const deviceName = (input && (input.name || input.manufacturer)) || 'MIDI';
    let msg = null;
    switch(typeByte){
      case 0xB0: msg = { type:'cc', channel, deviceId, deviceName, cc: d[1]||0, value: d[2]||0 }; break;
      case 0xE0: { const value14 = ((d[2]||0) << 7) | (d[1]||0); msg = { type:'pb', channel, deviceId, deviceName, value14 }; break; }
      case 0xD0: msg = { type:'at', channel, deviceId, deviceName, value: d[1]||0 }; break;
      case 0x90: if ((d[2]||0) === 0) return; msg = { type:'note', channel, deviceId, deviceName, note: d[1]||0, vel: d[2]||0 }; break;
      default: return;
    }
    if (learnMode && learnTarget){
      if (createBindingFromMessage(learnTarget, msg)){
        setMidiStatus(`Mapped ${bindingLabel(bindings.find(b=>b.targetId===learnTarget.id))} ‚Üí ‚Äú${learnTarget.id}‚Äù`);
        learnMode = false; midiLearnBtn.classList.remove('active'); midiLearnBtn.textContent = 'üéØ Learn: Off'; clearLearnTarget();
      } else setMidiStatus('Unsupported message for learn', false);
      return;
    }
    for (const b of bindings){ if (matchesBinding(b, msg)) applyMessageToBinding(b, msg); }
  }

  // Initial motion + load mappings
  setTimeout(() => { hueBase = Math.random()*360; edgeBase = Math.random()*360; for (const n of nodes){ const s=1.5+Math.random()*3.0; const a=Math.random()*Math.PI*2; n.vx=Math.cos(a)*s; n.vy=Math.sin(a)*s; }}, 250);
  (function loadBindings(){ try{ const raw = localStorage.getItem('glitchMeshMidiBindings_v1'); if (!raw) return; const arr=JSON.parse(raw); if (Array.isArray(arr)){ bindings=arr; for (const b of bindings){ const el=document.getElementById(b.targetId); if (el) { const lbl=(b.type==='cc'?`CC${b.controller}`:b.type==='pb'?'PitchBend':b.type==='at'?'Aftertouch':`Note${b.note}`)+` ch${b.channel}`; const badge=el.parentElement.querySelector('.midi-badge'); if (badge){ badge.textContent='üîó '+lbl; badge.hidden=false; } } } } }catch(e){} })();

})();
</script>
</body>
</html>