<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>glitch-mesh</title>
<style>
  :root { color-scheme: dark; }
  html,body { margin:0; height:100%; background:#000; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; }

  /* Top control panel */
  #ui {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.2);
    border-radius:12px; padding:10px 12px; font:14px system-ui, sans-serif; color:#fff;
    max-width:min(950px, calc(100vw - 20px));
    z-index:10;
  }
  .g { display:flex; flex-direction:column; gap:2px; }
  .g label { font-size:12px; opacity:.85 }
  .g input[type="range"] { width:140px; }
  button {
    appearance:none; background:#111; color:#7fb0ff; border:1px solid #7fb0ff;
    padding:9px 14px; border-radius:9px; font:14px system-ui,sans-serif; cursor:pointer;
  }
  #fps { font-size:12px; color:#9ad; opacity:.85; margin-left:4px }

  /* Bottom toggle to show/hide the panel */
  #uiToggleWrap {
    position:fixed; left:50%; bottom:10px; transform:translateX(-50%);
    background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.2);
    border-radius:999px; padding:8px 12px; color:#fff; font:13px system-ui,sans-serif;
    display:flex; align-items:center; gap:8px; z-index:10;
  }
  #uiToggle { width:18px; height:18px; }
  #flash {
    position:fixed; inset:0; background:#fff; opacity:0; pointer-events:none; z-index:5;
    transition: opacity .18s ease-out;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- Top controls -->
<div id="ui">
  <div class="g"><label>Nodes</label><input id="nodes" type="range" min="40" max="500" step="10" value="160"></div>
  <div class="g"><label>Link Radius</label><input id="radius" type="range" min="40" max="500" step="5" value="180"></div>
  <div class="g"><label>Trail (persistence)</label><input id="trail" type="range" min="0" max="0.95" step="0.01" value="0.25"></div>
  <div class="g"><label>Glitch (jitter)</label><input id="glitch" type="range" min="0" max="1.5" step="0.01" value="0.65"></div>
  <div class="g"><label>Teleport</label><input id="tele" type="range" min="0" max="0.05" step="0.001" value="0.006"></div>
  <div class="g"><label>Edge Thicc</label><input id="thick" type="range" min="0.4" max="4" step="0.1" value="1.2"></div>
  <div class="g"><label>Warp (time)</label><input id="warp" type="range" min="0.1" max="3" step="0.01" value="1.0"></div>
  <div class="g"><label>Explode Rate</label><input id="rate" type="range" min="0" max="3" step="0.01" value="0.7"></div>
  <div class="g"><label>Explode Power</label><input id="power" type="range" min="0" max="1200" step="10" value="520"></div>
  <button id="explode" type="button">üí• Explode</button>
  <button id="random"  type="button">üé≤ Randomize</button>
  <button id="pause"   type="button">‚è∏ Pause</button>
  <span id="fps"></span>
</div>

<!-- Bottom checkbox to show/hide the panel -->
<div id="uiToggleWrap">
  <input id="uiToggle" type="checkbox" checked>
  <label for="uiToggle">Show controls</label>
</div>

<!-- Quick flash layer for explosions -->
<div id="flash"></div>

<script>
(() => {
  // Canvas setup
  const $ = s => document.querySelector(s);
  const cv = $('#c');
  const ctx = cv.getContext('2d', { alpha:false, desynchronized:true });
  let DPR = Math.max(1, Math.min(devicePixelRatio || 1, 2));
  let W=0, H=0;
  function resize(){ W = cv.width = Math.floor(innerWidth * DPR); H = cv.height = Math.floor(innerHeight * DPR); }
  addEventListener('resize', resize, {passive:true}); resize();

  // UI
  const panel = $('#ui');
  const toggle = $('#uiToggle');
  toggle.addEventListener('change', () => {
    panel.style.display = toggle.checked ? 'flex' : 'none';
  });

  const UI = {
    nodes: $('#nodes'),
    radius: $('#radius'),
    trail: $('#trail'),
    glitch: $('#glitch'),
    tele:  $('#tele'),
    thick: $('#thick'),
    warp:  $('#warp'),
    rate:  $('#rate'),
    power: $('#power'),
  };

  // State
  let nodes = [];
  let playing = true;
  let last = performance.now();
  let timeScale = +UI.warp.value;
  let explodeCooldown = 0;

  // Helpers
  const flashEl = $('#flash');
  function screenFlash() {
    flashEl.style.opacity = '0.35';
    // force reflow then fade out
    requestAnimationFrame(() => { flashEl.style.opacity = '0'; });
  }

  function rnd(a=1){ return Math.random()*a; }
  function rndN(n=1){ return (Math.random()*2-1)*n; }

  function makeNodes(N){
    nodes = new Array(N).fill(0).map(()=>({
      x: rnd(W), y: rnd(H),
      vx: rndN(1.5), vy: rndN(1.5),
      r: 1.5 + Math.random()*3.5,
      hue: (160 + Math.random()*200)|0
    }));
  }
  makeNodes(+UI.nodes.value);

  // UI actions (ensure they‚Äôre bound and visible on mobile)
  $('#explode').addEventListener('click', () => burst(+UI.power.value));
  $('#random').addEventListener('click', () => randomize());
  $('#pause').addEventListener('click', () => {
    playing=!playing; $('#pause').textContent = playing ? '‚è∏ Pause' : '‚ñ∂Ô∏è Play';
  });
  UI.nodes.addEventListener('input', () => makeNodes(+UI.nodes.value));
  UI.warp.addEventListener('input', () => timeScale = +UI.warp.value);

  // Randomize now also re-seeds velocities so it‚Äôs clearly different
  function randomize(){
    for (const n of nodes){
      n.hue = (Math.random()*360)|0;
      const speed = 1.5 + Math.random()*3.0;
      const ang = Math.random()*Math.PI*2;
      n.vx = Math.cos(ang)*speed;
      n.vy = Math.sin(ang)*speed;
    }
  }

  // Burst = stronger radial impulse with distance falloff + flash
  function burst(P=600){
    const cx = rnd(W*0.6) + W*0.2;   // bias toward center-ish
    const cy = rnd(H*0.6) + H*0.2;
    const base = Math.max(100, P);
    for (const n of nodes){
      const dx = n.x - cx, dy = n.y - cy;
      const d = Math.hypot(dx,dy) + 1e-3;
      // inverse-square-ish falloff, clamped
      const f = Math.min(base / (d*d*0.002 + 1), base*0.02);
      const nx = dx / d, ny = dy / d;
      n.vx += nx * f;
      n.vy += ny * f;
    }
    screenFlash();
  }

  // Scheduled explosions (stochastic, rate slider) ‚Äî more frequent & obvious
  function autoExplode(dt){
    explodeCooldown -= dt;
    const rate = +UI.rate.value; // events/sec (approx)
    if (rate <= 0) return;
    if (explodeCooldown <= 0 && Math.random() < rate * dt) {
      burst(+UI.power.value * (0.7 + Math.random()*1.0));
      explodeCooldown = 0.12;
    }
  }

  // Draw loop
  const fpsEl = $('#fps'); let fpsAcc=0, fpsFrames=0, fpsT=0;
  function draw(t){
    const now = t, dtRaw = Math.max(0, (now - last) / 1000); last = now;
    const dt = dtRaw * timeScale;
    if (playing){
      // Trails
      const trail = +UI.trail.value;
      if (trail <= 0) { ctx.clearRect(0,0,W,H); }
      else { ctx.fillStyle = `rgba(0,0,0,${trail})`; ctx.fillRect(0,0,W,H); }

      // Params
      const jitter = +UI.glitch.value;
      const teleP  = +UI.tele.value;
      const linkR  = +UI.radius.value;
      const thick  = +UI.thick.value;

      autoExplode(dt);

      // Physics + draw nodes
      for (const n of nodes){
        // Glitchy random kicks (scaled with dt)
        if (Math.random() < (0.8*jitter) * dt) {
          n.vx += rndN(80*jitter) * dt;
          n.vy += rndN(80*jitter) * dt;
        }
        // Teleport
        if (Math.random() < teleP * dt) { n.x = rnd(W); n.y = rnd(H); }

        // Integrate
        n.x += n.vx * dt * 60;
        n.y += n.vy * dt * 60;

        // Soft boundary bounce
        if (n.x < 0) { n.x = 0; n.vx = Math.abs(n.vx); }
        if (n.x > W) { n.x = W; n.vx = -Math.abs(n.vx); }
        if (n.y < 0) { n.y = 0; n.vy = Math.abs(n.vy); }
        if (n.y > H) { n.y = H; n.vy = -Math.abs(n.vy); }

        // Node dots
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fillStyle = `hsl(${n.hue},85%,${45 + Math.min(40, Math.hypot(n.vx,n.vy))}%)`;
        ctx.fill();
      }

      // Edges / scaffolding (two-pass for depth)
      const N = nodes.length;
      ctx.lineCap = 'round';
      for (let pass=0; pass<2; pass++){
        ctx.lineWidth = (thick * (pass?1:0.5));
        for (let i=0;i<N;i++){
          const a = nodes[i];
          for (let j=i+1;j<N;j++){
            const b = nodes[j];
            const dx = a.x - b.x, dy = a.y - b.y;
            const d = Math.hypot(dx,dy);
            const reach = linkR * (pass?1.0:0.6);
            if (d < reach){
              const fade = 1 - d / reach;
              ctx.strokeStyle = `rgba(${180+pass*40},${210-pass*20},255,${0.06 + fade*0.5})`;
              // Mid-segment warp for glitch vibe
              const mx = (a.x+b.x)/2 + rndN(6 + 40*jitter*fade) * dt * 60;
              const my = (a.y+b.y)/2 + rndN(6 + 40*jitter*fade) * dt * 60;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(mx, my);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
          }
        }
      }
    }

    // FPS
    fpsAcc += 1/Math.max(dtRaw, 1e-6); fpsFrames++; fpsT += dtRaw;
    if (fpsT > 0.5) { fpsEl.textContent = `${(fpsAcc/fpsFrames).toFixed(0)} fps`; fpsAcc=0; fpsFrames=0; fpsT=0; }

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  // Initial flourish
  setTimeout(()=> burst(+UI.power.value*0.9), 350);
})();
</script>
</body>
</html>