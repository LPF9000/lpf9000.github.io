<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>glitch-network (iOS load fix)</title>
<style>
  html,body { margin:0; height:100%; background:#000; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; }
  #ui {
    position:fixed; top:12px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.45); padding:10px 16px; border-radius:12px;
    font-family:system-ui, sans-serif; font-size:16px; color:#fff;
    border:1px solid rgba(255,255,255,.25); display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  }
  button {
    appearance:none; background:#111; border:1px solid #59f; border-radius:8px;
    color:#59f; padding:10px 16px; font-size:16px; cursor:pointer;
  }
  input[type="range"]{ width:120px; }
  #status { font-size:12px; color:#9af; opacity:.95; min-width:200px }
  #player { display:none } /* we control playback via buttons; will show if needed */
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <button id="loadBtn">üìÅ Load</button>
  <button id="playBtn">‚ñ∂Ô∏è Play</button>
  <button id="pauseBtn">‚è∏ Pause</button>
  <label style="display:flex;align-items:center;gap:6px;">
    Vol <input id="vol" type="range" min="0" max="1" step="0.01" value="1">
  </label>
  <span id="status"></span>
</div>

<audio id="player" playsinline preload="metadata"></audio>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
const player = document.getElementById("player");
const vol = document.getElementById("vol");
const loadBtn = document.getElementById("loadBtn");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");

let W,H,DPR=Math.max(1,Math.min(window.devicePixelRatio||1,2));
function resize(){ W=canvas.width=innerWidth*DPR; H=canvas.height=innerHeight*DPR; }
addEventListener("resize",resize,{passive:true}); resize();

function setStatus(msg){ statusEl.textContent = msg || ""; }
function stat() {
  const rsMap = ["HAVE_NOTHING","HAVE_METADATA","HAVE_CURRENT_DATA","HAVE_FUTURE_DATA","HAVE_ENOUGH_DATA"];
  const rs = player.readyState!=null ? rsMap[player.readyState] || player.readyState : "?";
  const d = isFinite(player.duration) ? player.duration.toFixed(2) : "‚Äî";
  setStatus(`state:${rs} dur:${d}s`);
}

// ---- Audio graph ----
let actx, analyser, dataArray, srcNode, gainNode, urlRef=null, started=false;

function ensureAudio(){
  if (actx) return;
  const AC = window.AudioContext || window.webkitAudioContext;
  actx = new AC({ latencyHint: "interactive" });

  analyser = actx.createAnalyser();
  analyser.fftSize = 512;
  dataArray = new Uint8Array(analyser.frequencyBinCount);

  gainNode = actx.createGain();
  gainNode.gain.value = +vol.value;
  gainNode.connect(actx.destination);
  vol.oninput = () => { if (gainNode) gainNode.gain.value = +vol.value; };

  // Create MediaElementSource ONCE (lifetime of the element)
  srcNode = actx.createMediaElementSource(player);
  srcNode.connect(analyser);
  srcNode.connect(gainNode);

  // Mute element‚Äôs own output to avoid double audio; WebAudio path handles sound
  player.muted = true;
}

async function resumeCtx(){
  if (actx && actx.state !== "running") { try { await actx.resume(); } catch(_) {} }
}

function revokeOldURL(){ if (urlRef) { URL.revokeObjectURL(urlRef); urlRef = null; } }

// Load via picker
loadBtn.onclick = async () => {
  ensureAudio();
  await resumeCtx();

  const inp = document.createElement("input");
  inp.type = "file";
  // Leave accept empty to allow any; iOS will refuse unsupported codecs.
  // inp.accept = ".mp3,.m4a,.aac,.wav,.alac,.aif,.aiff,.caf,.flac,.ogg";
  inp.onchange = async () => {
    if (!(inp.files && inp.files[0])) return;
    const file = inp.files[0];

    // Reset element to a clean state
    player.removeAttribute("src");
    player.load();

    revokeOldURL();
    urlRef = URL.createObjectURL(file);
    player.src = urlRef;
    player.loop = true;

    setStatus("Loading metadata‚Ä¶");
    // Force a load cycle so iOS fetches metadata
    player.load();

    // Wait for metadata (duration becomes known); then try canplay
    await new Promise((res, rej) => {
      const onMeta = () => { stat(); cleanup(); res(); };
      const onErr = () => { setStatus("Error loading file (unsupported?)"); cleanup(); res(); };
      const cleanup = () => {
        player.removeEventListener("loadedmetadata", onMeta);
        player.removeEventListener("error", onErr);
      };
      player.addEventListener("loadedmetadata", onMeta, { once:true });
      player.addEventListener("error", onErr, { once:true });
    });

    // Optional: wait for canplay to be extra safe
    await new Promise((res) => {
      if (player.readyState >= 3) return res();
      const onCP = () => { res(); player.removeEventListener("canplay", onCP); };
      player.addEventListener("canplay", onCP);
      // Also resolve after short timeout to avoid hanging
      setTimeout(res, 250);
    });

    stat();
  };
  inp.click();
};

// Play/Pause
playBtn.onclick = async () => {
  ensureAudio();
  await resumeCtx();
  try { await player.play(); started = true; stat(); }
  catch(e){
    // As fallback, expose native controls; one tap on Play always works
    player.controls = true;
    player.style.display = "block";
    setStatus("Tap Play on the control bar to start.");
  }
};
pauseBtn.onclick = () => { try { player.pause(); stat(); } catch(_){} };

// Media events to keep you informed
player.addEventListener("loadedmetadata", stat);
player.addEventListener("canplay", stat);
player.addEventListener("timeupdate", stat);
player.addEventListener("error", () => {
  const err = player.error;
  let msg = "Playback error.";
  if (err) {
    const map = {1:"aborted",2:"network",3:"decode",4:"src not supported"};
    msg = `Playback error (${map[err.code]||err.code}).`;
  }
  setStatus(msg + " Try MP3, M4A/AAC, WAV, or ALAC on iPhone.");
  player.controls = true;
  player.style.display = "block";
});

// ---- Visuals: glitchy architectural network ----
const N=160, nodes=[];
for(let i=0;i<N;i++){
  nodes.push({ x:Math.random()*W, y:Math.random()*H,
               vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2,
               r:2+Math.random()*3 });
}

function energy(){
  if(!started || !analyser) return 0;
  analyser.getByteFrequencyData(dataArray);
  let s=0; for (let v of dataArray) s+=v;
  return s/(dataArray.length*255);
}

function draw(){
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0,0,W,H);

  const e = energy();
  // Architecture + glitches
  for (let n of nodes){
    if (Math.random() < 0.025 + e*0.08) {
      n.vx += (Math.random()-0.5)*12*e;
      n.vy += (Math.random()-0.5)*12*e;
      if (Math.random() < 0.004 + e*0.012) { n.x = Math.random()*W; n.y = Math.random()*H; }
    }
    n.x += n.vx; n.y += n.vy;
    if (n.x<0||n.x>W) n.vx*=-1;
    if (n.y<0||n.y>H) n.vy*=-1;

    ctx.beginPath();
    ctx.arc(n.x,n.y,n.r,0,Math.PI*2);
    ctx.fillStyle = `hsl(${170+e*210},80%,${45+e*40}%)`;
    ctx.fill();
  }

  const reach = 120 + e*240;
  ctx.lineWidth = 0.8 + e*2.4;
  for (let i=0;i<N;i++){
    for (let j=i+1;j<N;j++){
      const dx=nodes[i].x-nodes[j].x, dy=nodes[i].y-nodes[j].y, d=Math.hypot(dx,dy);
      if (d < reach){
        const a = 1 - d/(reach+1);
        ctx.strokeStyle = `rgba(180,210,255,${0.07 + a*0.55})`;
        ctx.beginPath();
        ctx.moveTo(nodes[i].x, nodes[i].y);
        const mx = (nodes[i].x + nodes[j].x)/2 + (Math.random()-0.5)*8*e;
        const my = (nodes[i].y + nodes[j].y)/2 + (Math.random()-0.5)*8*e;
        ctx.lineTo(mx, my);
        ctx.lineTo(nodes[j].x, nodes[j].y);
        ctx.stroke();
      }
    }
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>